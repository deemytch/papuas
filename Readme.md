# Что это

Набор утилит "Парламентёр" предназначен для выполнения скриптов на серверах так, чтобы операторы не имели доступа к указанным серверам. Прокся, короче.

# Первоначальная настройка

0. ruby 2.3.0, bundle, redis
1. cd <папка проекта> ; bundle install --path=vendor/bundle --jobs <по вкусу>
2. Отредактировать файл config/global.yml - внести туда имя базы, пользователя и пароль
3. Запустить ./dbsetup.sh,
   если не получится - создать базу и пользователя вручную,
   затем запустить bundle exec rake db:migrate
4. Прочесть справку по команде pjreq
  ./pjreq -h
5. Создать необходимые папки на серверах операторов
6. Надобавлять нужных серверов и пользователей
  При добавлении утилита проверяет наличие и доступность всех указанных серверов, пользователей и файлов ключей
  Можно использовать сокращённые имена серверов и не писать имя пользователя, если это есть в ~/.ssh/config
7. По готовности запустить ./bigbro.rb
  Режим по умолчанию - найти задачи и выполнить не оключаясь от консоли.
  Справка ./bigbro -h
  При -j prod утилита уйдёт в фон и будет сканировать сервера с исходниками
  с интервалом в секундах из config/global.yml[:global][:query_delay]
  Там же написано, куда он кладёт логи.
  Если при старте невозможно открыть лог-файл, утилита упадёт и пожалуется.

# Как это

Оператор пишет скрипт для выполнения задачи на сервере (Нода1). Затем пишет настроечный файл (doit-случайный-текст.yml) с параметрами запуска этого скрипта. Кладёт оба файла и, возможно, другие, необходимые для скрипта файлы, в заранее заданную папку на сервере (Источник1:/папка) и надеется на лучшее.

*Внимание! Зарезервированные имена: doit*.yml task*.yml done*.yml*

Утилита bigbro.rb каждые Ч секунд опрашивает папку (Источник1:/папка) на предмет наличия там новых поступлений. Увидев файл настроек doit*.yml он радостно загружает оттуда такие данные: 
* где взять скрипт
* есть ли дополнительные файлы
* на каких серверах (Нода1, Нода10) исполнять этот скрипт и какие данные (логин) для доступа к нодам использовать.

Если формат файла опознан и задача в базе создана, исходный файл переименовывается в task-id-*.yml

Весь вывод STDOUT и STDERR выполненного скрипта утилита складывает обратно в папку где взяла, переименовывает файл task-id-*.yml в done-id-*.yml и дописывает в него имена файлов stderr.log, stdout.log и код возврата скрипта.

Образец файла задачи находится в *docs/doit-with-love.yml*

# Тут нужен админ

## Что где

Структура баз описана в файле docs/db.pdf
Скрипт генерации базы - dbsetup.rb

## Программа *pjreq*

### Как это происходит

Вход и выполнение скрипта пользователя на целевом узле.

#### Ключ и логин для входа

1. используется имя пользователя, заданное в описании задачи
2. используется имя пользователя, заданное в ~/.ssh/config
3. используется ключ (pem) из базы, связанный с найденным именем

#### При добавлении узла или источника в базу настроек:

1. ищется ключ, явно заданный в командной строке
2. используются настройки из .ssh/config на управляющем компьютере
3. ищем ключ #{user}@#{node}.#{port}.[rsa|ed25519|pem] в подпапке *keys*
4. Затем ключ преобразовывается в .pem формат и записывается в базу

### Примеры

  ./pjreq -h

## Программа *bigbro.rb*

Утилита bigbro может выполнять задачи в трех режимах:
-j single - однократный последовательный прогон, не отсоединяясь от терминала
-j tasks - однократная загрузка задач в менеджер задач sidekiq (и выполнение)
-j prod - сканирование папок с интервалом из настроек и загрузка их на выполнение в sidekiq
Настройки sidekiq - в config/sidekiq.yml
Номер базы redis - в config/global.yml

* Проверка настроек
* Проверка базы на целостность и непротиворечивость
* Загрузка заданий
* Проверка наличия целевых узлов
* Логин на целевые узлы с указанными реквизитами
